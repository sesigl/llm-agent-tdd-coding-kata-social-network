diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..b6fef8f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,40 @@
+target/
+!.mvn/wrapper/maven-wrapper.jar
+!**/src/main/**/target/
+!**/src/test/**/target/
+
+### IntelliJ IDEA ###
+.idea/modules.xml
+.idea/jarRepositories.xml
+.idea/compiler.xml
+.idea/libraries/
+*.iws
+*.iml
+*.ipr
+
+### Eclipse ###
+.apt_generated
+.classpath
+.factorypath
+.project
+.settings
+.springBeans
+.sts4-cache
+
+### NetBeans ###
+/nbproject/private/
+/nbbuild/
+/dist/
+/nbdist/
+/.nb-gradle/
+build/
+!**/src/main/**/build/
+!**/src/test/**/build/
+
+### VS Code ###
+.vscode/
+
+### Mac OS ###
+.DS_Store
+
+.envrc
diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
index 0000000..7bc07ec
--- /dev/null
+++ b/.idea/.gitignore
@@ -0,0 +1,10 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Environment-dependent path to Maven home directory
+/mavenHomeManager.xml
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
index 0000000..942f3a2
--- /dev/null
+++ b/.idea/encodings.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="file://$PROJECT_DIR$/src/main/kotlin" charset="UTF-8" />
+    <file url="file://$PROJECT_DIR$/src/main/resources" charset="UTF-8" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/kotlinc.xml b/.idea/kotlinc.xml
new file mode 100644
index 0000000..fe63bb6
--- /dev/null
+++ b/.idea/kotlinc.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="KotlinJpsPluginSettings">
+    <option name="version" value="1.9.23" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 0000000..65da7c1
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="MavenProjectsManager">
+    <option name="originalFiles">
+      <list>
+        <option value="$PROJECT_DIR$/pom.xml" />
+      </list>
+    </option>
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="temurin-21 (3)" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 0000000..94a25f7
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.sdkmanrc b/.sdkmanrc
new file mode 100644
index 0000000..8e05285
--- /dev/null
+++ b/.sdkmanrc
@@ -0,0 +1,3 @@
+# Enable auto-env through the sdkman_auto_env config
+# Add key=value pairs of SDKs to use below
+java=21.0.7-tem
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..2d291c8
--- /dev/null
+++ b/README.md
@@ -0,0 +1,152 @@
+# Social Network Coding Kata
+
+
+This repository contains different branches with correct but different solutions to compare effectiveness of AI programming.
+
+The following branches are available:
+- `tdd-only` - Pure TDD without AI
+- `tdd-with-ai` TDD with AI
+
+The comparison wont be perfect. I practiced implementing this kata before, and did it again with different limitations. This might not reflect reality.
+
+## Hypothesis
+
+LLMs have become very fast and powerful generating code. 
+
+Hence, if instructions are clear they can solve problems in seconds.
+
+The biggest limiting factor of LLMs is that the quality of code they are trained on, might be too low for what you expect. Building on "average" code
+your company might be go fast in the early stages, but will slow down as the codebase grows.
+
+This can be addressed by using TDD to provide from the beginning long-living executable guardrails. That's nothing new, but the question is if LLMs can accelerate engineers so we get the best of both worlds.
+
+## The tooling
+
+To make TDD more strict and comparable, a technique [test-commit-revert](https://nvoulgaris.com/test-commit-revert/) is used. This gives us a more strict ruleset how to do TDD, but also
+allows us to do more analysis comparing development with and without agentic help. 
+
+> **Note:** The `./tcr.sh` script supports a `-c` parameter (e.g., `./tcr.sh -c`). This allows you to pass a command to be executed automatically after each TCR cycle, which is especially helpful for agentic workflows or automation scenarios where you want to trigger additional actions (such as LLM agents, notifications, or metrics collection) after each commit or revert.
+
+### The development cycle
+
+TCR is a more strict TDD. I recommend the following executing cycle (which might be different how others do TCR):
+
+Preparation:
+- run `./tcr.sh` to start the TCR process
+
+Cycle:
+1. Write a test, press "f" to check if the build or test fails
+2. Do the implementation
+3. Press "ENTER" to execute the TCR check. If tests are green then the changes are committed. If not the changed are reset. In both cases there is an empty or not empty commit with a useful commit message leveraging Gemini for traceability.
+4. Start again with Step 1
+
+## The Kata
+
+Source: https://kata-log.rocks/social-network-kata
+
+This is an incremental kata to simulate a real business situation: work your way through the steps in order, but do not read the next requirement before you have finished your current one.
+
+Your Team is tired of all those boring tasks like bowling game scores, bank accounts, singing songs or commanding mars rovers. This time you want to do something truly innovative: A Social Network!
+
+### Backlog of requirements
+
+- Posting: Alice can publish messages to her personal timeline
+- Reading: Bob can view Alice’s timeline
+- Following: Charlie can subscribe to Alice’s and Bob’s timelines, and view an aggregated list of all subscriptions
+- Mentions: Bob can link to Charlie in a message using “@”
+- Links: Alice can link to a clickable web resource in a message
+- Direct Messages: Mallory can send a private message to Alice, which is a timeline entry only visible to Alice
+
+## Evaluation
+
+To get insights about how efficient development is, and how to evaluate the result with different metrics related to number of features covered, additional cases covered, clean code, cohesion, coupling, test coverage etc. metrics will be collected leveraging state of the art LLM.
+
+### Metrics
+
+- Main Use Cases Coverage between 0/6 to 6/6
+- Number of additional Edge/Use Cases
+- Time Until Completion in seconds
+- Test-to-Code lines of code ratio 
+- Number of average assertions per test
+- Cyclomatic complexity counting the number of linearly independent paths through the code
+- Code duplication in percentage
+- Code Smells
+- Behavior vs. Implementation Focus rated by the LLM between 1 (not behavior focused tests) to 5 (excellent bdd)
+- Clean Code of Implementation (following best practices from Martin J. Martins and other pioneers) rated by the LLM between 1 (not clean) to 5 (excellent clean code)
+- Clean Code of Tests, e.g. readability of Assertions,  (following best practices from Martin J. Martins and other pioneers) rated by the LLM between 1 (not clean) to 5 (excellent clean code)
+
+### Evaluation Prompt
+
+```
+Analyze the following data from a 30-minute Test-Commit-Revert (TCR) coding session for the "Social Network Kata". The goal is to evaluate the development process based on the provided commit log, final source code, and final test code.
+
+**Context:**
+- The session duration was 30 minutes (1800 seconds).
+- The methodology used was Test-Commit-Revert (TCR), where tests must pass for changes to be committed; otherwise, they are reverted.
+- The kata involves implementing features for a simple social network (Posting, Reading, Following, Mentions, Links, Direct Messages).
+- The commit log includes timestamps and messages indicating successful commits or reverts.
+
+**Input Data:**
+
+1.  **Commit Log (including timestamps, commit messages, and commit/revert status):**
+    ```
+    [PASTE COMMIT LOG DATA HERE]
+    ```
+
+2.  **Final Source Code:**
+    ```[language]
+    [PASTE FINAL SOURCE CODE HERE]
+    ```
+
+3.  **Final Test Code:**
+    ```[language]
+    [PASTE FINAL TEST CODE HERE]
+    ```
+
+**Analysis Task:**
+
+Based *only* on the provided data, calculate the following metrics and provide a general summary of the session. Adhere strictly to the definitions provided below.
+
+**Metric Definitions:**
+
+1.  `main_use_cases_coverage`: Integer (0-6). Count how many of the 6 main requirements (Posting, Reading, Following, Mentions, Links, Direct Messages) appear to be implemented and tested according to the final code and tests.
+2.  `additional_edge_cases`: Integer. Count the number of distinct edge cases or alternative scenarios explicitly handled in the tests beyond the most basic path for each implemented main requirement.
+3.  `time_to_completion_or_session_end_seconds`: Integer. Report 1800 (the session duration) as the kata was likely not fully completed in 30 mins. If, exceptionally, all 6 use cases were verifiably completed *before* the 30min mark according to the commit log, estimate the time based on the last relevant commit timestamp. Otherwise, always use 1800.
+4.  `test_to_code_ratio`: Float. Calculate the ratio of lines of code in the final test files to the lines of code in the final source files (excluding comments and blank lines if possible, otherwise total lines). State the method used (e.g., total lines or non-comment/blank lines).
+5.  `average_assertions_per_test`: Float. Calculate the average number of assertion statements per test method/function found in the final test code.
+6.  `cyclomatic_complexity`: Integer. Estimate the *average* cyclomatic complexity across the functions/methods in the *final source code*. If possible, state the tool/methodology used for estimation (e.g., counting decision points + 1).
+7.  `code_duplication_percentage`: Float. Estimate the percentage of duplicated code within the *final source code*. Briefly state the basis for this estimation (e.g., visual inspection, assumed tooling).
+8.  `code_smells`: List of strings. Identify potential code smells present in the *final source code* based on common definitions (e.g., Long Method, Large Class, Feature Envy, Duplicated Code, etc.). List the identified smells.
+9.  `test_focus_rating`: Integer (1-5). Rate the tests based on their focus on *behavior* (what the system should do) versus *implementation details* (how it does it). 1 = Heavily implementation-focused, difficult to understand behavior; 5 = Clearly specifies behavior (BDD-like), independent of implementation details.
+10. `implementation_clean_code_rating`: Integer (1-5). Rate the *final source code* based on general Clean Code principles (e.g., meaningful names, small functions, SRP, comments quality, formatting). 1 = Poor adherence; 5 = Excellent adherence.
+11. `test_clean_code_rating`: Integer (1-5). Rate the *final test code* based on general Clean Code principles (e.g., readability, structure like Arrange-Act-Assert, clear assertion messages, meaningful test names). 1 = Poor adherence; 5 = Excellent adherence.
+12. `ai_support_level`: "none", "completion", "edit" or "agent". The amount of AI support in the task.
+13. `day`: Integer 0-30. The number of times I have done the tasks with different level of AI support.
+14. `description`: Overall description of the test run.
+
+**Output Format:**
+
+Provide the results in two parts:
+1.  A JSON object containing the calculated metrics.
+2.  A general summary section (plain text).
+
+**Example JSON Structure:**
+```json
+{
+  "ai_support_level": "completion",
+  "day": 2,
+  "main_use_cases_coverage": 3,
+  "additional_edge_cases": 2,
+  "time_to_completion_or_session_end_seconds": 1800,
+  "test_to_code_ratio": 1.8,
+  "average_assertions_per_test": 1.5,
+  "cyclomatic_complexity": 2,
+  "code_duplication_percentage": 5.0,
+  "code_smells": ["Duplicated Code", "Primitive Obsession"],
+  "test_focus_rating": 4,
+  "implementation_clean_code_rating": 3,
+  "test_clean_code_rating": 4
+}
+```
+
+`
\ No newline at end of file
diff --git a/evaluateBranch.sh b/evaluateBranch.sh
new file mode 100755
index 0000000..b47996f
--- /dev/null
+++ b/evaluateBranch.sh
@@ -0,0 +1,251 @@
+#!/bin/bash
+
+# Accept branch name as first argument (optional)
+BRANCH_NAME="$1"
+
+# Function to call Gemini API with the evaluation prompt
+gemini_evaluate() {
+  local prompt="$1"
+  local api_url="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}"
+  local response
+  response=$(curl -s \
+    -X POST \
+    -H "Content-Type: application/json" \
+    "$api_url" \
+    -d '{
+      "contents": [
+        { "parts": [ { "text": "'"$(echo "$prompt" | sed 's/"/\\"/g')"'"} ] }
+      ]
+    }') || {
+      echo "Error: API request failed" >&2
+      return 1
+    }
+  # Try to extract the text part (Gemini returns a JSON with .candidates[0].content.parts[0].text)
+  if command -v jq &>/dev/null; then
+    printf '%s' "$response" | jq -r '.candidates[0].content.parts[0].text // empty'
+  else
+    printf '%s' "$response" | grep -o '"text":[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"text":[[:space:]]*"//;s/"$//'
+  fi
+}
+
+# 1. Get all commit messages from the TCR run (everything prefixed with [TCR])
+if [ -n "$BRANCH_NAME" ]; then
+  echo "Getting logs from branch: $BRANCH_NAME"
+  TCR_LOG=$(git log "$BRANCH_NAME" --grep="^\[TCR\]" --date=iso)
+else
+  # fail, branch name is required
+  echo "Error: Branch name is required. Usage: $0 <branch_name>" >&2
+  exit 1
+fi
+
+# --- Extract ai_support_level using Gemini ---
+echo "Preparing prompt for ai_support_level extraction..."
+read -r -d '' AI_LEVEL_PROMPT << EOM
+Given the following branch name from a coding session, determine the value for "ai_support_level" according to these options: "none", "completion", "edit", or "agent". Only output the value as a single word, nothing else.
+
+Branch name:
+$BRANCH_NAME
+EOM
+
+echo "Calling Gemini to extract ai_support_level..."
+AI_SUPPORT_LEVEL=$(gemini_evaluate "$AI_LEVEL_PROMPT" | head -1 | tr -d '\r\n ')
+echo "Gemini returned ai_support_level: '$AI_SUPPORT_LEVEL'"
+
+if [[ ! "$AI_SUPPORT_LEVEL" =~ ^(none|completion|edit|agent)$ ]]; then
+  echo "Warning: Could not extract a valid ai_support_level from Gemini. Got: '$AI_SUPPORT_LEVEL'. Defaulting to 'none'." >&2
+  AI_SUPPORT_LEVEL="none"
+else
+  echo "ai_support_level is valid: $AI_SUPPORT_LEVEL"
+fi
+
+# --- Extract day using Gemini ---
+echo "Preparing prompt for day extraction..."
+read -r -d '' DAY_PROMPT << EOM
+Given the following branch name from a coding session, extract the integer value for "day" (0-30) that is part of the branch name. Only output the integer, nothing else.
+
+Branch name:
+$BRANCH_NAME
+EOM
+
+echo "Calling Gemini to extract day..."
+DAY=$(gemini_evaluate "$DAY_PROMPT" | head -1 | tr -d '\r\n ')
+echo "Gemini returned day: '$DAY'"
+
+if [[ ! "$DAY" =~ ^[0-9]\{1,2\}$ && ! "$DAY" =~ ^[0-9]$ && ! "$DAY" =~ ^[1-2][0-9]$ && ! "$DAY" =~ ^30$ ]]; then
+  echo "Warning: Could not extract a valid day from Gemini. Got: '$DAY'. Defaulting to '0'." >&2
+  DAY="0"
+elif (( DAY < 0 || DAY > 30 )); then
+  echo "Warning: Extracted day '$DAY' is out of range 0-30. Defaulting to '0'." >&2
+  DAY="0"
+else
+  echo "day is valid: $DAY"
+fi
+
+# 2. Gather the final source and test code from the branch (using git show)
+echo "Collecting source and test files from branch $BRANCH_NAME..."
+SRC_CODE=""
+TEST_CODE=""
+
+# Get list of source files in the branch
+BRANCH_SRC_FILES=$(git ls-tree -r --name-only "$BRANCH_NAME" -- src/main 2>/dev/null)
+BRANCH_TEST_FILES=$(git ls-tree -r --name-only "$BRANCH_NAME" -- src/test 2>/dev/null)
+
+if [ -n "$BRANCH_SRC_FILES" ]; then
+  for file in $BRANCH_SRC_FILES; do
+    SRC_CODE+="\n\n// File: $file\n"
+    SRC_CODE+="$(git show "$BRANCH_NAME:$file" 2>/dev/null)"
+  done
+fi
+
+if [ -n "$BRANCH_TEST_FILES" ]; then
+  for file in $BRANCH_TEST_FILES; do
+    TEST_CODE+="\n\n// File: $file\n"
+    TEST_CODE+="$(git show "$BRANCH_NAME:$file" 2>/dev/null)"
+  done
+fi
+
+# 3. Get initial files from main branch
+echo "Collecting initial files from main branch..."
+INITIAL_SRC_CODE=""
+INITIAL_TEST_CODE=""
+
+# Get list of source files in main
+MAIN_SRC_FILES=$(git ls-tree -r --name-only main -- src/main 2>/dev/null)
+MAIN_TEST_FILES=$(git ls-tree -r --name-only main -- src/test 2>/dev/null)
+
+if [ -n "$MAIN_SRC_FILES" ]; then
+  for file in $MAIN_SRC_FILES; do
+    INITIAL_SRC_CODE+="\n\n// File: $file\n"
+    INITIAL_SRC_CODE+="$(git show "main:$file" 2>/dev/null)"
+  done
+fi
+
+if [ -n "$MAIN_TEST_FILES" ]; then
+  for file in $MAIN_TEST_FILES; do
+    INITIAL_TEST_CODE+="\n\n// File: $file\n"
+    INITIAL_TEST_CODE+="$(git show "main:$file" 2>/dev/null)"
+  done
+fi
+
+# 4. Get git diff between main and the branch
+echo "Getting diff between main and $BRANCH_NAME..."
+GIT_DIFF=$(git diff main..$BRANCH_NAME)
+
+# 5. Prepare the evaluation prompt (from README.md)
+read -r -d '' PROMPT << EOM
+Analyze the following data from a 30-minute Test-Commit-Revert (TCR) coding session for the "Social Network Kata". The goal is to evaluate the development process based on the provided commit log, initial code, final code, and git diff.
+
+**ai_support_level for this branch:** $AI_SUPPORT_LEVEL
+**day for this branch:** $DAY
+
+**Context:**
+- Get the exact session duration from the commits, but it should be about 30m (1800 seconds).
+- The methodology used was Test-Commit-Revert (TCR), where tests must pass for changes to be committed; otherwise, they are reverted.
+- The kata involves implementing features for a simple social network (Posting, Reading, Following, Mentions, Links, Direct Messages).
+- The commit log includes timestamps and messages indicating successful commits or reverts.
+
+**Input Data:**
+
+1.  **Commit Log (including timestamps, commit messages, and commit/revert status):**
+
+$TCR_LOG
+
+2.  **Initial Source Code (from main branch):**
+
+$INITIAL_SRC_CODE
+
+3.  **Initial Test Code (from main branch):**
+
+$INITIAL_TEST_CODE
+
+4.  **Final Source Code (from $BRANCH_NAME branch):**
+
+$SRC_CODE
+
+5.  **Final Test Code (from $BRANCH_NAME branch):**
+
+$TEST_CODE
+
+6.  **Git Diff (showing changes from main to $BRANCH_NAME):**
+
+$GIT_DIFF
+
+**Analysis Instructions:**
+- Compare the initial code from the main branch with the final code from the branch to understand what development work was done.
+- Use the git diff to see exactly what changes were made during the session.
+- Consider how the commit messages align with the actual code changes you can see in the diff.
+- Analyze the progression of development based on commit messages and the resulting code.
+
+**Analysis Task:**
+
+Based on the provided data, calculate the following metrics and provide a general summary of the session. Adhere strictly to the definitions provided below.
+
+**Metric Definitions:**
+
+ai_support_level: "none", "completion", "edit" or "agent". The amount of AI support in the task.
+day: Integer 0-30. The number of times I have done the tasks with different level of AI support.
+main_use_cases_coverage: Integer (0-6). Count how many of the 6 main requirements (Posting, Reading, Following, Mentions, Links, Direct Messages) appear to be implemented and tested according to the final code and tests.
+additional_edge_cases: Integer. Count the number of distinct edge cases or alternative scenarios explicitly handled in the tests beyond the most basic path for each implemented main requirement.
+time_to_completion_in_seconds: Integer. The time between the first and the last commit provided, which calculates the exact duration of the session.
+test_to_code_ratio: Float. Calculate the ratio of lines of code in the final test files to the lines of code in the final source files (excluding comments and blank lines if possible, otherwise total lines). State the method used (e.g., total lines or non-comment/blank lines).
+average_assertions_per_test: Float. Calculate the average number of assertion statements per test method/function found in the final test code.
+cyclomatic_complexity: Integer. Estimate the *average* cyclomatic complexity across the functions/methods in the *final source code*. If possible, state the tool/methodology used for estimation (e.g., counting decision points + 1).
+code_duplication_percentage: Float. Estimate the percentage of duplicated code within the *final source code*. Briefly state the basis for this estimation (e.g., visual inspection, assumed tooling).
+code_smells: Integer. Identify the number of potential code smells present in the *final source code* based on common definitions (e.g., Long Method, Large Class, Feature Envy, Duplicated Code, etc.). List the identified smells.
+test_focus_rating: Integer (1-5). Rate the tests based on their focus on *behavior* (what the system should do) versus *implementation details* (how it does it). 1 = Heavily implementation-focused, difficult to understand behavior; 5 = Clearly specifies behavior (BDD-like), independent of implementation details.
+implementation_clean_code_rating: Integer (1-5). Rate the *final source code* based on general Clean Code principles (e.g., meaningful names, small functions, SRP, comments quality, formatting). 1 = Poor adherence; 5 = Excellent adherence.
+test_clean_code_rating: Integer (1-5). Rate the *final test code* based on general Clean Code principles (e.g., readability, structure like Arrange-Act-Assert, clear assertion messages, meaningful test names). 1 = Poor adherence; 5 = Excellent adherence.
+commits_per_minute: Float. Calculates how many commits per minute are done, to measure the duration of the feedback cycle.
+tcr_revert_rate: Float (1.0-0.0) Calculates how many percentage of commits are revert commits resetting progress. 1 being 100%, 0.5 being 50%, and 0 being 0%.
+
+**Output Format:**
+
+Provide ONLY the JSON object containing the calculated metrics and an overall generated description:
+
+
+**Example JSON Structure:**
+{
+  "ai_support_level": "completion",
+  "day": 2,
+  "main_use_cases_coverage": 3,
+  "additional_edge_cases": 2,
+  "time_to_completion_in_seconds": 1800,
+  "test_to_code_ratio": 1.8,
+  "average_assertions_per_test": 1.5,
+  "cyclomatic_complexity": 2,
+  "code_duplication_percentage": 5.0,
+  "code_smells": 2,
+  "test_focus_rating": 4,
+  "implementation_clean_code_rating": 3,
+  "test_clean_code_rating": 4,
+  "description": "The coding session, which employed the Test-Commit-Revert (TCR) methodology, spanned approximately 27 minutes and 16 seconds according to the commit timestamps. The commit log indicates a development process that involved adding basic timeline functionality (publish, retrieve), handling multiple messages, and implementing access control features (owner-only restriction, general access, granular access). The log also suggests refactoring efforts to improve test setup. However, the provided final source code and test code are in an initial, largely empty state. The TimelineService class is defined but contains no implementation, and the TimelineServiceTest class contains only one empty test method named example. This final state does not reflect the features described as being added and committed in the commit history. Consequently, based strictly on the final code and tests, none of the main social network kata requirements are met, there are no implemented behaviors or tested edge cases, and code quality metrics like complexity and duplication are minimal or non-applicable due to the lack of code. The tests, in their final form, lack clear focus or adherence to clean code principles. The most notable aspect of this session's data is the significant discrepancy between the commit history, which portrays steady progress and successful commits under TCR, and the final code snapshot provided.",
+  "commits_per_minute": 1.2,
+  "tcr_revert_rate": 0.2
+}
+EOM
+
+echo "GEMINI FINAL PROMPT: $PROMPT"
+
+# 6. Call Gemini API to get the evaluation JSON and append to results.ndjson
+
+# Ensure API key is provided
+: "${GEMINI_API_KEY:?Environment variable GEMINI_API_KEY must be set}"
+
+# Call Gemini and process the result
+EVAL_RESULT=$(gemini_evaluate "$PROMPT")
+
+# Extract the JSON part (first code block)
+JSON_LINE=$(printf '%s\n' "$EVAL_RESULT" | awk '/^```json/{flag=1;next}/^```/{flag=0}flag' | sed '/^$/d')
+
+if [ -z "$JSON_LINE" ]; then
+  echo "No JSON result found in Gemini response. Full response:" >&2
+  echo "$EVAL_RESULT" >&2
+  exit 1
+fi
+
+# Append JSON to results.ndjson
+printf '%s\n' "$JSON_LINE" >> results.ndjson
+
+echo "Evaluation JSON appended to results.ndjson."
+# Optionally, print the summary section as well
+printf '%s\n' "$EVAL_RESULT" | awk '/^```json/{flag=0}flag;/^```json/{flag=1}' | sed '/^$/d'
diff --git a/initial_code_diff.txt b/initial_code_diff.txt
new file mode 100644
index 0000000..2acaf04
--- /dev/null
+++ b/initial_code_diff.txt
@@ -0,0 +1,885 @@
+diff --git a/.gitignore b/.gitignore
+new file mode 100644
+index 0000000..b6fef8f
+--- /dev/null
++++ b/.gitignore
+@@ -0,0 +1,40 @@
++target/
++!.mvn/wrapper/maven-wrapper.jar
++!**/src/main/**/target/
++!**/src/test/**/target/
++
++### IntelliJ IDEA ###
++.idea/modules.xml
++.idea/jarRepositories.xml
++.idea/compiler.xml
++.idea/libraries/
++*.iws
++*.iml
++*.ipr
++
++### Eclipse ###
++.apt_generated
++.classpath
++.factorypath
++.project
++.settings
++.springBeans
++.sts4-cache
++
++### NetBeans ###
++/nbproject/private/
++/nbbuild/
++/dist/
++/nbdist/
++/.nb-gradle/
++build/
++!**/src/main/**/build/
++!**/src/test/**/build/
++
++### VS Code ###
++.vscode/
++
++### Mac OS ###
++.DS_Store
++
++.envrc
+diff --git a/.idea/.gitignore b/.idea/.gitignore
+new file mode 100644
+index 0000000..7bc07ec
+--- /dev/null
++++ b/.idea/.gitignore
+@@ -0,0 +1,10 @@
++# Default ignored files
++/shelf/
++/workspace.xml
++# Editor-based HTTP Client requests
++/httpRequests/
++# Environment-dependent path to Maven home directory
++/mavenHomeManager.xml
++# Datasource local storage ignored files
++/dataSources/
++/dataSources.local.xml
+diff --git a/.idea/encodings.xml b/.idea/encodings.xml
+new file mode 100644
+index 0000000..942f3a2
+--- /dev/null
++++ b/.idea/encodings.xml
+@@ -0,0 +1,7 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="Encoding">
++    <file url="file://$PROJECT_DIR$/src/main/kotlin" charset="UTF-8" />
++    <file url="file://$PROJECT_DIR$/src/main/resources" charset="UTF-8" />
++  </component>
++</project>
+\ No newline at end of file
+diff --git a/.idea/kotlinc.xml b/.idea/kotlinc.xml
+new file mode 100644
+index 0000000..fe63bb6
+--- /dev/null
++++ b/.idea/kotlinc.xml
+@@ -0,0 +1,6 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="KotlinJpsPluginSettings">
++    <option name="version" value="1.9.23" />
++  </component>
++</project>
+\ No newline at end of file
+diff --git a/.idea/misc.xml b/.idea/misc.xml
+new file mode 100644
+index 0000000..65da7c1
+--- /dev/null
++++ b/.idea/misc.xml
+@@ -0,0 +1,14 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="ExternalStorageConfigurationManager" enabled="true" />
++  <component name="MavenProjectsManager">
++    <option name="originalFiles">
++      <list>
++        <option value="$PROJECT_DIR$/pom.xml" />
++      </list>
++    </option>
++  </component>
++  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="temurin-21 (3)" project-jdk-type="JavaSDK">
++    <output url="file://$PROJECT_DIR$/out" />
++  </component>
++</project>
+\ No newline at end of file
+diff --git a/.idea/vcs.xml b/.idea/vcs.xml
+new file mode 100644
+index 0000000..94a25f7
+--- /dev/null
++++ b/.idea/vcs.xml
+@@ -0,0 +1,6 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project version="4">
++  <component name="VcsDirectoryMappings">
++    <mapping directory="$PROJECT_DIR$" vcs="Git" />
++  </component>
++</project>
+\ No newline at end of file
+diff --git a/.sdkmanrc b/.sdkmanrc
+new file mode 100644
+index 0000000..8e05285
+--- /dev/null
++++ b/.sdkmanrc
+@@ -0,0 +1,3 @@
++# Enable auto-env through the sdkman_auto_env config
++# Add key=value pairs of SDKs to use below
++java=21.0.7-tem
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..e13a403
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,149 @@
++# Social Network Coding Kata
++
++
++This repository contains different branches with correct but different solutions to compare effectiveness of AI programming.
++
++The following branches are available:
++- `tdd-only` - Pure TDD without AI
++- `tdd-with-ai` TDD with AI
++
++The comparison wont be perfect. I practiced implementing this kata before, and did it again with different limitations. This might not reflect reality.
++
++## Hypothesis
++
++LLMs have become very fast and powerful generating code. 
++
++Hence, if instructions are clear they can solve problems in seconds.
++
++The biggest limiting factor of LLMs is that the quality of code they are trained on, might be too low for what you expect. Building on "average" code
++your company might be go fast in the early stages, but will slow down as the codebase grows.
++
++This can be addressed by using TDD to provide from the beginning long-living executable guardrails. That's nothing new, but the question is if LLMs can accelerate engineers so we get the best of both worlds.
++
++## The tooling
++
++To make TDD more strict and comparable, a technique [test-commit-revert](https://nvoulgaris.com/test-commit-revert/) is used. This gives us a more strict ruleset how to do TDD, but also
++allows us to do more analysis comparing development with and without agentic help. 
++
++### The development cycle
++
++TCR is a more strict TDD. I recommend the following executing cycle (which might be different how others do TCR):
++
++Preparation:
++- run `./tcr.sh` to start the TCR process
++
++Cycle:
++1. Write a test, press "f" to check if the build or test fails
++2. Do the implementation
++3. Press "ENTER" to execute the TCR check. If tests are green then the changes are committed. If not the changed are reset. In both cases there is an empty or not empty commit with a useful commit message leveraging Gemini for traceability.
++4. Start again with Step 1
++
++## The Kata
++
++Source: https://kata-log.rocks/social-network-kata
++
++This is an incremental kata to simulate a real business situation: work your way through the steps in order, but do not read the next requirement before you have finished your current one.
++
++Your Team is tired of all those boring tasks like bowling game scores, bank accounts, singing songs or commanding mars rovers. This time you want to do something truly innovative: A Social Network!
++
++### Backlog of requirements
++
++- Posting: Alice can publish messages to her personal timeline
++- Reading: Bob can view Alice’s timeline
++- Following: Charlie can subscribe to Alice’s and Bob’s timelines, and view an aggregated list of all subscriptions
++- Mentions: Bob can link to Charlie in a message using “@”
++- Links: Alice can link to a clickable web resource in a message
++- Direct Messages: Mallory can send a private message to Alice, which is a timeline entry only visible to Alice
++
++## Evaluation
++
++To get insights about how efficient development is, and how to evaluate the result with different metrics related to number of features covered, additional cases covered, clean code, cohesion, coupling, test coverage etc. metrics will be collected leveraging state of the art LLM.
++
++### Metrics
++
++- Main Use Cases Coverage between 0/6 to 6/6
++- Number of additional Edge/Use Cases
++- Time Until Completion in seconds
++- Test-to-Code lines of code ratio 
++- Number of average assertions per test
++- Cyclomatic complexity counting the number of linearly independent paths through the code
++- Code duplication in percentage
++- Code Smells
++- Behavior vs. Implementation Focus rated by the LLM between 1 (not behavior focused tests) to 5 (excellent bdd)
++- Clean Code of Implementation (following best practices from Martin J. Martins and other pioneers) rated by the LLM between 1 (not clean) to 5 (excellent clean code)
++- Clean Code of Tests, e.g. readability of Assertions,  (following best practices from Martin J. Martins and other pioneers) rated by the LLM between 1 (not clean) to 5 (excellent clean code)
++
++### Evaluation Prompt
++
++```
++Analyze the following data from a 30-minute Test-Commit-Revert (TCR) coding session for the "Social Network Kata". The goal is to evaluate the development process based on the provided commit log, final source code, and final test code.
++
++**Context:**
++- The session duration was 30 minutes (1800 seconds).
++- The methodology used was Test-Commit-Revert (TCR), where tests must pass for changes to be committed; otherwise, they are reverted.
++- The kata involves implementing features for a simple social network (Posting, Reading, Following, Mentions, Links, Direct Messages).
++- The commit log includes timestamps and messages indicating successful commits or reverts.
++
++**Input Data:**
++
++1.  **Commit Log (including timestamps, commit messages, and commit/revert status):**
++    ```
++    [PASTE COMMIT LOG DATA HERE]
++    ```
++
++2.  **Final Source Code:**
++    ```[language]
++    [PASTE FINAL SOURCE CODE HERE]
++    ```
++
++3.  **Final Test Code:**
++    ```[language]
++    [PASTE FINAL TEST CODE HERE]
++    ```
++
++**Analysis Task:**
++
++Based *only* on the provided data, calculate the following metrics and provide a general summary of the session. Adhere strictly to the definitions provided below.
++
++**Metric Definitions:**
++
++1.  `main_use_cases_coverage`: Integer (0-6). Count how many of the 6 main requirements (Posting, Reading, Following, Mentions, Links, Direct Messages) appear to be implemented and tested according to the final code and tests.
++2.  `additional_edge_cases`: Integer. Count the number of distinct edge cases or alternative scenarios explicitly handled in the tests beyond the most basic path for each implemented main requirement.
++3.  `time_to_completion_or_session_end_seconds`: Integer. Report 1800 (the session duration) as the kata was likely not fully completed in 30 mins. If, exceptionally, all 6 use cases were verifiably completed *before* the 30min mark according to the commit log, estimate the time based on the last relevant commit timestamp. Otherwise, always use 1800.
++4.  `test_to_code_ratio`: Float. Calculate the ratio of lines of code in the final test files to the lines of code in the final source files (excluding comments and blank lines if possible, otherwise total lines). State the method used (e.g., total lines or non-comment/blank lines).
++5.  `average_assertions_per_test`: Float. Calculate the average number of assertion statements per test method/function found in the final test code.
++6.  `cyclomatic_complexity`: Integer. Estimate the *average* cyclomatic complexity across the functions/methods in the *final source code*. If possible, state the tool/methodology used for estimation (e.g., counting decision points + 1).
++7.  `code_duplication_percentage`: Float. Estimate the percentage of duplicated code within the *final source code*. Briefly state the basis for this estimation (e.g., visual inspection, assumed tooling).
++8.  `code_smells`: List of strings. Identify potential code smells present in the *final source code* based on common definitions (e.g., Long Method, Large Class, Feature Envy, Duplicated Code, etc.). List the identified smells.
++9.  `test_focus_rating`: Integer (1-5). Rate the tests based on their focus on *behavior* (what the system should do) versus *implementation details* (how it does it). 1 = Heavily implementation-focused, difficult to understand behavior; 5 = Clearly specifies behavior (BDD-like), independent of implementation details.
++10. `implementation_clean_code_rating`: Integer (1-5). Rate the *final source code* based on general Clean Code principles (e.g., meaningful names, small functions, SRP, comments quality, formatting). 1 = Poor adherence; 5 = Excellent adherence.
++11. `test_clean_code_rating`: Integer (1-5). Rate the *final test code* based on general Clean Code principles (e.g., readability, structure like Arrange-Act-Assert, clear assertion messages, meaningful test names). 1 = Poor adherence; 5 = Excellent adherence.
++12. `ai_support_level`: "none", "completion", "edit" or "agent". The amount of AI support in the task.
++13. `day`: Integer 0-30. The number of times I have done the tasks with different level of AI support.
++14. `description`: Overall description of the test run.
++
++**Output Format:**
++
++Provide the results in two parts:
++1.  A JSON object containing the calculated metrics.
++2.  A general summary section (plain text).
++
++**Example JSON Structure:**
++```json
++{
++  "ai_support_level": "completion",
++  "day": 2,
++  "main_use_cases_coverage": 3,
++  "additional_edge_cases": 2,
++  "time_to_completion_or_session_end_seconds": 1800,
++  "test_to_code_ratio": 1.8,
++  "average_assertions_per_test": 1.5,
++  "cyclomatic_complexity": 2,
++  "code_duplication_percentage": 5.0,
++  "code_smells": ["Duplicated Code", "Primitive Obsession"],
++  "test_focus_rating": 4,
++  "implementation_clean_code_rating": 3,
++  "test_clean_code_rating": 4
++}
++```
++
+diff --git a/evaluateBranch.sh b/evaluateBranch.sh
+new file mode 100755
+index 0000000..b47996f
+--- /dev/null
++++ b/evaluateBranch.sh
+@@ -0,0 +1,251 @@
++#!/bin/bash
++
++# Accept branch name as first argument (optional)
++BRANCH_NAME="$1"
++
++# Function to call Gemini API with the evaluation prompt
++gemini_evaluate() {
++  local prompt="$1"
++  local api_url="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}"
++  local response
++  response=$(curl -s \
++    -X POST \
++    -H "Content-Type: application/json" \
++    "$api_url" \
++    -d '{
++      "contents": [
++        { "parts": [ { "text": "'"$(echo "$prompt" | sed 's/"/\\"/g')"'"} ] }
++      ]
++    }') || {
++      echo "Error: API request failed" >&2
++      return 1
++    }
++  # Try to extract the text part (Gemini returns a JSON with .candidates[0].content.parts[0].text)
++  if command -v jq &>/dev/null; then
++    printf '%s' "$response" | jq -r '.candidates[0].content.parts[0].text // empty'
++  else
++    printf '%s' "$response" | grep -o '"text":[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"text":[[:space:]]*"//;s/"$//'
++  fi
++}
++
++# 1. Get all commit messages from the TCR run (everything prefixed with [TCR])
++if [ -n "$BRANCH_NAME" ]; then
++  echo "Getting logs from branch: $BRANCH_NAME"
++  TCR_LOG=$(git log "$BRANCH_NAME" --grep="^\[TCR\]" --date=iso)
++else
++  # fail, branch name is required
++  echo "Error: Branch name is required. Usage: $0 <branch_name>" >&2
++  exit 1
++fi
++
++# --- Extract ai_support_level using Gemini ---
++echo "Preparing prompt for ai_support_level extraction..."
++read -r -d '' AI_LEVEL_PROMPT << EOM
++Given the following branch name from a coding session, determine the value for "ai_support_level" according to these options: "none", "completion", "edit", or "agent". Only output the value as a single word, nothing else.
++
++Branch name:
++$BRANCH_NAME
++EOM
++
++echo "Calling Gemini to extract ai_support_level..."
++AI_SUPPORT_LEVEL=$(gemini_evaluate "$AI_LEVEL_PROMPT" | head -1 | tr -d '\r\n ')
++echo "Gemini returned ai_support_level: '$AI_SUPPORT_LEVEL'"
++
++if [[ ! "$AI_SUPPORT_LEVEL" =~ ^(none|completion|edit|agent)$ ]]; then
++  echo "Warning: Could not extract a valid ai_support_level from Gemini. Got: '$AI_SUPPORT_LEVEL'. Defaulting to 'none'." >&2
++  AI_SUPPORT_LEVEL="none"
++else
++  echo "ai_support_level is valid: $AI_SUPPORT_LEVEL"
++fi
++
++# --- Extract day using Gemini ---
++echo "Preparing prompt for day extraction..."
++read -r -d '' DAY_PROMPT << EOM
++Given the following branch name from a coding session, extract the integer value for "day" (0-30) that is part of the branch name. Only output the integer, nothing else.
++
++Branch name:
++$BRANCH_NAME
++EOM
++
++echo "Calling Gemini to extract day..."
++DAY=$(gemini_evaluate "$DAY_PROMPT" | head -1 | tr -d '\r\n ')
++echo "Gemini returned day: '$DAY'"
++
++if [[ ! "$DAY" =~ ^[0-9]\{1,2\}$ && ! "$DAY" =~ ^[0-9]$ && ! "$DAY" =~ ^[1-2][0-9]$ && ! "$DAY" =~ ^30$ ]]; then
++  echo "Warning: Could not extract a valid day from Gemini. Got: '$DAY'. Defaulting to '0'." >&2
++  DAY="0"
++elif (( DAY < 0 || DAY > 30 )); then
++  echo "Warning: Extracted day '$DAY' is out of range 0-30. Defaulting to '0'." >&2
++  DAY="0"
++else
++  echo "day is valid: $DAY"
++fi
++
++# 2. Gather the final source and test code from the branch (using git show)
++echo "Collecting source and test files from branch $BRANCH_NAME..."
++SRC_CODE=""
++TEST_CODE=""
++
++# Get list of source files in the branch
++BRANCH_SRC_FILES=$(git ls-tree -r --name-only "$BRANCH_NAME" -- src/main 2>/dev/null)
++BRANCH_TEST_FILES=$(git ls-tree -r --name-only "$BRANCH_NAME" -- src/test 2>/dev/null)
++
++if [ -n "$BRANCH_SRC_FILES" ]; then
++  for file in $BRANCH_SRC_FILES; do
++    SRC_CODE+="\n\n// File: $file\n"
++    SRC_CODE+="$(git show "$BRANCH_NAME:$file" 2>/dev/null)"
++  done
++fi
++
++if [ -n "$BRANCH_TEST_FILES" ]; then
++  for file in $BRANCH_TEST_FILES; do
++    TEST_CODE+="\n\n// File: $file\n"
++    TEST_CODE+="$(git show "$BRANCH_NAME:$file" 2>/dev/null)"
++  done
++fi
++
++# 3. Get initial files from main branch
++echo "Collecting initial files from main branch..."
++INITIAL_SRC_CODE=""
++INITIAL_TEST_CODE=""
++
++# Get list of source files in main
++MAIN_SRC_FILES=$(git ls-tree -r --name-only main -- src/main 2>/dev/null)
++MAIN_TEST_FILES=$(git ls-tree -r --name-only main -- src/test 2>/dev/null)
++
++if [ -n "$MAIN_SRC_FILES" ]; then
++  for file in $MAIN_SRC_FILES; do
++    INITIAL_SRC_CODE+="\n\n// File: $file\n"
++    INITIAL_SRC_CODE+="$(git show "main:$file" 2>/dev/null)"
++  done
++fi
++
++if [ -n "$MAIN_TEST_FILES" ]; then
++  for file in $MAIN_TEST_FILES; do
++    INITIAL_TEST_CODE+="\n\n// File: $file\n"
++    INITIAL_TEST_CODE+="$(git show "main:$file" 2>/dev/null)"
++  done
++fi
++
++# 4. Get git diff between main and the branch
++echo "Getting diff between main and $BRANCH_NAME..."
++GIT_DIFF=$(git diff main..$BRANCH_NAME)
++
++# 5. Prepare the evaluation prompt (from README.md)
++read -r -d '' PROMPT << EOM
++Analyze the following data from a 30-minute Test-Commit-Revert (TCR) coding session for the "Social Network Kata". The goal is to evaluate the development process based on the provided commit log, initial code, final code, and git diff.
++
++**ai_support_level for this branch:** $AI_SUPPORT_LEVEL
++**day for this branch:** $DAY
++
++**Context:**
++- Get the exact session duration from the commits, but it should be about 30m (1800 seconds).
++- The methodology used was Test-Commit-Revert (TCR), where tests must pass for changes to be committed; otherwise, they are reverted.
++- The kata involves implementing features for a simple social network (Posting, Reading, Following, Mentions, Links, Direct Messages).
++- The commit log includes timestamps and messages indicating successful commits or reverts.
++
++**Input Data:**
++
++1.  **Commit Log (including timestamps, commit messages, and commit/revert status):**
++
++$TCR_LOG
++
++2.  **Initial Source Code (from main branch):**
++
++$INITIAL_SRC_CODE
++
++3.  **Initial Test Code (from main branch):**
++
++$INITIAL_TEST_CODE
++
++4.  **Final Source Code (from $BRANCH_NAME branch):**
++
++$SRC_CODE
++
++5.  **Final Test Code (from $BRANCH_NAME branch):**
++
++$TEST_CODE
++
++6.  **Git Diff (showing changes from main to $BRANCH_NAME):**
++
++$GIT_DIFF
++
++**Analysis Instructions:**
++- Compare the initial code from the main branch with the final code from the branch to understand what development work was done.
++- Use the git diff to see exactly what changes were made during the session.
++- Consider how the commit messages align with the actual code changes you can see in the diff.
++- Analyze the progression of development based on commit messages and the resulting code.
++
++**Analysis Task:**
++
++Based on the provided data, calculate the following metrics and provide a general summary of the session. Adhere strictly to the definitions provided below.
++
++**Metric Definitions:**
++
++ai_support_level: "none", "completion", "edit" or "agent". The amount of AI support in the task.
++day: Integer 0-30. The number of times I have done the tasks with different level of AI support.
++main_use_cases_coverage: Integer (0-6). Count how many of the 6 main requirements (Posting, Reading, Following, Mentions, Links, Direct Messages) appear to be implemented and tested according to the final code and tests.
++additional_edge_cases: Integer. Count the number of distinct edge cases or alternative scenarios explicitly handled in the tests beyond the most basic path for each implemented main requirement.
++time_to_completion_in_seconds: Integer. The time between the first and the last commit provided, which calculates the exact duration of the session.
++test_to_code_ratio: Float. Calculate the ratio of lines of code in the final test files to the lines of code in the final source files (excluding comments and blank lines if possible, otherwise total lines). State the method used (e.g., total lines or non-comment/blank lines).
++average_assertions_per_test: Float. Calculate the average number of assertion statements per test method/function found in the final test code.
++cyclomatic_complexity: Integer. Estimate the *average* cyclomatic complexity across the functions/methods in the *final source code*. If possible, state the tool/methodology used for estimation (e.g., counting decision points + 1).
++code_duplication_percentage: Float. Estimate the percentage of duplicated code within the *final source code*. Briefly state the basis for this estimation (e.g., visual inspection, assumed tooling).
++code_smells: Integer. Identify the number of potential code smells present in the *final source code* based on common definitions (e.g., Long Method, Large Class, Feature Envy, Duplicated Code, etc.). List the identified smells.
++test_focus_rating: Integer (1-5). Rate the tests based on their focus on *behavior* (what the system should do) versus *implementation details* (how it does it). 1 = Heavily implementation-focused, difficult to understand behavior; 5 = Clearly specifies behavior (BDD-like), independent of implementation details.
++implementation_clean_code_rating: Integer (1-5). Rate the *final source code* based on general Clean Code principles (e.g., meaningful names, small functions, SRP, comments quality, formatting). 1 = Poor adherence; 5 = Excellent adherence.
++test_clean_code_rating: Integer (1-5). Rate the *final test code* based on general Clean Code principles (e.g., readability, structure like Arrange-Act-Assert, clear assertion messages, meaningful test names). 1 = Poor adherence; 5 = Excellent adherence.
++commits_per_minute: Float. Calculates how many commits per minute are done, to measure the duration of the feedback cycle.
++tcr_revert_rate: Float (1.0-0.0) Calculates how many percentage of commits are revert commits resetting progress. 1 being 100%, 0.5 being 50%, and 0 being 0%.
++
++**Output Format:**
++
++Provide ONLY the JSON object containing the calculated metrics and an overall generated description:
++
++
++**Example JSON Structure:**
++{
++  "ai_support_level": "completion",
++  "day": 2,
++  "main_use_cases_coverage": 3,
++  "additional_edge_cases": 2,
++  "time_to_completion_in_seconds": 1800,
++  "test_to_code_ratio": 1.8,
++  "average_assertions_per_test": 1.5,
++  "cyclomatic_complexity": 2,
++  "code_duplication_percentage": 5.0,
++  "code_smells": 2,
++  "test_focus_rating": 4,
++  "implementation_clean_code_rating": 3,
++  "test_clean_code_rating": 4,
++  "description": "The coding session, which employed the Test-Commit-Revert (TCR) methodology, spanned approximately 27 minutes and 16 seconds according to the commit timestamps. The commit log indicates a development process that involved adding basic timeline functionality (publish, retrieve), handling multiple messages, and implementing access control features (owner-only restriction, general access, granular access). The log also suggests refactoring efforts to improve test setup. However, the provided final source code and test code are in an initial, largely empty state. The TimelineService class is defined but contains no implementation, and the TimelineServiceTest class contains only one empty test method named example. This final state does not reflect the features described as being added and committed in the commit history. Consequently, based strictly on the final code and tests, none of the main social network kata requirements are met, there are no implemented behaviors or tested edge cases, and code quality metrics like complexity and duplication are minimal or non-applicable due to the lack of code. The tests, in their final form, lack clear focus or adherence to clean code principles. The most notable aspect of this session's data is the significant discrepancy between the commit history, which portrays steady progress and successful commits under TCR, and the final code snapshot provided.",
++  "commits_per_minute": 1.2,
++  "tcr_revert_rate": 0.2
++}
++EOM
++
++echo "GEMINI FINAL PROMPT: $PROMPT"
++
++# 6. Call Gemini API to get the evaluation JSON and append to results.ndjson
++
++# Ensure API key is provided
++: "${GEMINI_API_KEY:?Environment variable GEMINI_API_KEY must be set}"
++
++# Call Gemini and process the result
++EVAL_RESULT=$(gemini_evaluate "$PROMPT")
++
++# Extract the JSON part (first code block)
++JSON_LINE=$(printf '%s\n' "$EVAL_RESULT" | awk '/^```json/{flag=1;next}/^```/{flag=0}flag' | sed '/^$/d')
++
++if [ -z "$JSON_LINE" ]; then
++  echo "No JSON result found in Gemini response. Full response:" >&2
++  echo "$EVAL_RESULT" >&2
++  exit 1
++fi
++
++# Append JSON to results.ndjson
++printf '%s\n' "$JSON_LINE" >> results.ndjson
++
++echo "Evaluation JSON appended to results.ndjson."
++# Optionally, print the summary section as well
++printf '%s\n' "$EVAL_RESULT" | awk '/^```json/{flag=0}flag;/^```json/{flag=1}' | sed '/^$/d'
+diff --git a/pom.xml b/pom.xml
+new file mode 100644
+index 0000000..f728570
+--- /dev/null
++++ b/pom.xml
+@@ -0,0 +1,99 @@
++<?xml version="1.0" encoding="UTF-8"?>
++<project xmlns="http://maven.apache.org/POM/4.0.0"
++         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
++         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
++    <modelVersion>4.0.0</modelVersion>
++
++    <groupId>org.example</groupId>
++    <artifactId>social-network-coding-kata-manual</artifactId>
++    <version>1.0-SNAPSHOT</version>
++
++    <properties>
++        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
++        <kotlin.code.style>official</kotlin.code.style>
++        <kotlin.compiler.jvmTarget>21</kotlin.compiler.jvmTarget>
++        <maven.compiler.source>21</maven.compiler.source>
++        <maven.compiler.target>21</maven.compiler.target>
++    </properties>
++
++    <repositories>
++        <repository>
++            <id>mavenCentral</id>
++            <url>https://repo1.maven.org/maven2/</url>
++        </repository>
++    </repositories>
++
++    <build>
++        <sourceDirectory>src/main/kotlin</sourceDirectory>
++        <testSourceDirectory>src/test/kotlin</testSourceDirectory>
++        <plugins>
++            <plugin>
++                <groupId>org.jetbrains.kotlin</groupId>
++                <artifactId>kotlin-maven-plugin</artifactId>
++                <version>1.9.23</version>
++                <executions>
++                    <execution>
++                        <id>compile</id>
++                        <phase>compile</phase>
++                        <goals>
++                            <goal>compile</goal>
++                        </goals>
++                    </execution>
++                    <execution>
++                        <id>test-compile</id>
++                        <phase>test-compile</phase>
++                        <goals>
++                            <goal>test-compile</goal>
++                        </goals>
++                    </execution>
++                </executions>
++            </plugin>
++            <plugin>
++                <artifactId>maven-compiler-plugin</artifactId>
++                <version>3.11.0</version>
++                <configuration>
++                    <source>21</source>
++                    <target>21</target>
++                </configuration>
++            </plugin>
++            <plugin>
++                <artifactId>maven-surefire-plugin</artifactId>
++                <version>3.2.5</version>
++            </plugin>
++            <plugin>
++                <artifactId>maven-failsafe-plugin</artifactId>
++                <version>3.2.5</version>
++            </plugin>
++            <plugin>
++                <groupId>org.codehaus.mojo</groupId>
++                <artifactId>exec-maven-plugin</artifactId>
++                <version>3.2.0</version>
++                <configuration>
++                    <mainClass>MainKt</mainClass>
++                </configuration>
++            </plugin>
++        </plugins>
++    </build>
++
++    <dependencies>
++        <dependency>
++            <groupId>org.jetbrains.kotlin</groupId>
++            <artifactId>kotlin-test-junit5</artifactId>
++            <version>1.9.23</version>
++            <scope>test</scope>
++        </dependency>
++        <dependency>
++            <groupId>org.junit.jupiter</groupId>
++            <artifactId>junit-jupiter</artifactId>
++            <version>5.11.0</version>
++            <scope>test</scope>
++        </dependency>
++        <dependency>
++            <groupId>org.jetbrains.kotlin</groupId>
++            <artifactId>kotlin-stdlib</artifactId>
++            <version>1.9.23</version>
++        </dependency>
++    </dependencies>
++
++</project>
++
+diff --git a/renovate.json b/renovate.json
+new file mode 100644
+index 0000000..4a1ef1e
+--- /dev/null
++++ b/renovate.json
+@@ -0,0 +1,24 @@
++{
++  "extends": [
++    "config:base"
++  ],
++  "automerge": true,
++  "automergeType": "branch",
++  "labels": ["dependencies"],
++  "prConcurrentLimit": 5,
++  "prHourlyLimit": 2,
++  "dependencyDashboard": true,
++  "packageRules": [
++    {
++      "matchUpdateTypes": ["minor", "patch"],
++      "automerge": true
++    },
++    {
++      "matchUpdateTypes": ["major"],
++      "automerge": false
++    }
++  ],
++  "requireStatusChecks": true,
++  "rebaseWhen": "auto"
++}
++
+diff --git a/results.ndjson b/results.ndjson
+new file mode 100644
+index 0000000..90f4d1e
+--- /dev/null
++++ b/results.ndjson
+@@ -0,0 +1,36 @@
++{
++  "ai_support_level": "completion",
++  "day": 1,
++  "main_use_cases_coverage": 3,
++  "additional_edge_cases": 1,
++  "time_to_completion_in_seconds": 1283,
++  "test_to_code_ratio": 0.65,
++  "average_assertions_per_test": 1.0,
++  "cyclomatic_complexity": 2,
++  "code_duplication_percentage": 0.0,
++  "code_smells": ["Dead Code"],
++  "test_focus_rating": 4,
++  "implementation_clean_code_rating": 4,
++  "test_clean_code_rating": 4,
++  "description": "The coding session, employing the Test-Commit-Revert (TCR) methodology with 'completion' level AI support on day 1, spanned approximately 21 minutes and 23 seconds according to the commit timestamps. The developer made steady progress, successfully committing 9 times without any reverts, resulting in a revert rate of 0.0. The commit log indicates a clear progression, averaging about 0.42 commits per minute: starting with basic message publishing and retrieval, moving to per-user timelines, allowing other users to view timelines, adding the subscription feature, and then refactoring the code by introducing `Timeline` and `TimelineRepository` classes and moving subscriber notification logic into the `Timeline` class. Finally, the test for multiple subscriptions was extended. The final code implements three main use cases of the social network kata: Posting, Reading, and Following. The tests cover the basic paths for these features and include one additional scenario (reading another user's timeline). The code structure is improved through refactoring into multiple classes, demonstrating good separation of concerns, although an unused field (\"Dead Code\") exists in the TimelineService. Both the implementation and test code adhere well to clean code principles, and the tests are behavior-focused with descriptive names. The average number of assertions per test is 1.0, indicating focused tests. The cyclomatic complexity is low, reflecting simple logic, and no significant code duplication was identified. The test-to-code ratio is approximately 0.65 (based on non-blank lines). Overall, this session shows effective progress and good coding practices within the constraints of TCR.",
++  "commits_per_minute": 0.42,
++  "tcr_revert_rate": 0.0
++}
++{
++  "ai_support_level": "completion",
++  "day": 2,
++  "main_use_cases_coverage": 5,
++  "additional_edge_cases": 3,
++  "time_to_completion_in_seconds": 1542,
++  "test_to_code_ratio": 0.986,
++  "average_assertions_per_test": 1.0,
++  "cyclomatic_complexity": 2,
++  "code_duplication_percentage": 0.0,
++  "code_smells": 1,
++  "test_focus_rating": 4,
++  "implementation_clean_code_rating": 4,
++  "test_clean_code_rating": 5,
++  "description": "The coding session, utilizing the Test-Commit-Revert (TCR) methodology with AI completion support, lasted exactly 25 minutes and 42 seconds (1542 seconds) based on the timestamps of the 14 successful commits. The commit log details a progressive development process beginning with the fundamental ability to post and retrieve messages, evolving quickly to support personal timelines, viewing other users' timelines, and implementing subscription functionality. Significant refactoring steps are evident, extracting timeline handling into a dedicated `Timeline` class, introducing a `TimelineRepository` for data access, and moving subscriber notification logic into the `Timeline` class itself, reflecting a clear focus on improving design and separation of concerns. The latter commits focused on implementing and testing encoding for user mentions (`@`) and web links (`http`/`https`). Based on the final code and tests, five of the six main social network requirements (Posting, Reading, Following via Subscription, Mentions, and Links) appear to be implemented. The tests cover basic scenarios for these features and include specific edge cases such as handling multiple subscriptions, messages containing both self and other user mentions, and messages with multiple URLs. Code quality is generally good, with well-structured classes (`TimelineService`, `TimelineRepository`, `Timeline`), small focused methods, and clear separation of concerns. One minor code smell, an unused `subscribers` field in `TimelineService`, was identified. Code duplication is minimal. Tests are well-written with highly descriptive names and follow a clear Arrange-Act-Assert pattern, focusing on observable behavior rather than implementation details, resulting in a high test clean code rating. The test-to-code ratio is nearly 1:1 (using total lines). The average cyclomatic complexity is low, indicative of simple function logic. The TCR methodology was followed successfully, with a 0% revert rate (based on the provided log of successful commits), resulting in steady, well-tested progress.",
++  "commits_per_minute": 0.54,
++  "tcr_revert_rate": 0.0
++}
+diff --git a/src/main/kotlin/org/codingkata/socialnetwork/TimelineService.kt b/src/main/kotlin/org/codingkata/socialnetwork/TimelineService.kt
+new file mode 100644
+index 0000000..917b226
+--- /dev/null
++++ b/src/main/kotlin/org/codingkata/socialnetwork/TimelineService.kt
+@@ -0,0 +1,4 @@
++package org.codingkata.socialnetwork
++
++class TimelineService {
++}
+\ No newline at end of file
+diff --git a/src/test/kotlin/org/codingkata/socialnetwork/TimelineServiceTest.kt b/src/test/kotlin/org/codingkata/socialnetwork/TimelineServiceTest.kt
+new file mode 100644
+index 0000000..94abcaa
+--- /dev/null
++++ b/src/test/kotlin/org/codingkata/socialnetwork/TimelineServiceTest.kt
+@@ -0,0 +1,10 @@
++package org.codingkata.socialnetwork.org.codingkata.socialnetwork
++
++import org.junit.jupiter.api.Test
++
++class TimelineServiceTest {
++
++    @Test
++    fun example() {
++    }
++}
+\ No newline at end of file
+diff --git a/tcr.sh b/tcr.sh
+new file mode 100755
+index 0000000..6e5f668
+--- /dev/null
++++ b/tcr.sh
+@@ -0,0 +1,130 @@
++#!/usr/bin/env bash
++# TCR (Test && Commit || Revert) automation script
++# Usage: tcr.sh [-d]  # -d = debug mode
++
++# parse flags
++DEBUG=0
++while getopts "d" opt; do
++  case $opt in
++    d) DEBUG=1 ;;
++  esac
++done
++shift $((OPTIND -1))
++
++log_debug() {
++  if [ "$DEBUG" -eq 1 ]; then
++    echo "$@" >&2
++  fi
++}
++
++# Default commit message
++COMMIT_MSG="WIP"
++
++# strict mode + better error detection
++set -euo pipefail
++
++# ensure API key is provided
++: "${GEMINI_API_KEY:?Environment variable GEMINI_API_KEY must be set}"
++
++# Function to summarize added code using Gemini API
++summarize_code() {
++  local diff_content="$1"
++  local response summary
++  # use the documented Gemini flash model
++  local api_url="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}"
++
++  response=$(curl -s \
++    -X POST \
++    -H "Content-Type: application/json" \
++    "$api_url" \
++    -d '{
++      "contents": [
++        {
++          "parts": [
++            {
++              "text": "I am doing TCR (test commit revert) and you are my commit summarizer. Your response should only be the commit message and the commit description, no other content or masking. Summarize the following code changes for a commit message:\n'"$(echo "$diff_content" | sed 's/"/\\"/g')"'"
++            }
++          ]
++        }
++      ]
++    }') || {
++      echo "Error: API request failed" >&2
++      return 1
++    }
++  log_debug "API response: $response"
++
++  # parse with jq if installed, else fallback to grep/sed
++  if command -v jq &>/dev/null; then
++    summary=$(printf '%s' "$response" \
++      | jq -r '.candidates[0].content.parts[0].text // empty')
++  else
++    summary=$(printf '%s' "$response" \
++      | grep -o '"text":[[:space:]]*"[^"]*"' \
++      | head -1 \
++      | sed 's/.*"text":[[:space:]]*"//;s/"$//')
++  fi
++
++  printf '%s' "$summary"
++}
++
++# Main loop: wait for Enter key, then run tests and handle git accordingly
++echo "Starting a TCR coding kata session... Have fun 🚀!"
++echo "--------------------------------------------------"
++
++while true; do
++  # read a single key (silent, no newline)
++  read -rsn1 -p $'\n Enter - run the TCR cycle \n f - run tests only \n Ctrl+C to exit\n' key
++  echo
++  if [[ $key == "" ]]; then
++    # full TCR cycle
++    echo "Running tests..."
++    # capture maven output with colors (force ANSI) while printing live
++    TMP_OUT=$(mktemp)
++    TEST_OUTPUT=""  # Initialize to avoid unbound variable
++    if mvn -Dstyle.color=always clean test 2>&1 | tee "$TMP_OUT"; then
++      TEST_OUTPUT=$(cat "$TMP_OUT"); rm "$TMP_OUT"
++      echo "Tests passed. Preparing commit..."
++      git add -A
++      ADDED_CODE=$(git diff --cached)
++      log_debug "Diff content: $ADDED_CODE"
++
++      if [ -n "$ADDED_CODE" ]; then
++        SUMMARY=$(summarize_code "$ADDED_CODE") || SUMMARY=""
++        SUMMARY=${SUMMARY:-"No summary from API"}
++        COMMIT_MSG="[TCR] $SUMMARY"
++        log_debug "Commit message: $COMMIT_MSG"
++        git commit -m "$COMMIT_MSG"
++      else
++        echo "No code changes detected. Keeping going..."
++        continue
++      fi
++
++    else
++      TEST_OUTPUT=$(cat "$TMP_OUT" 2>/dev/null || true); rm -f "$TMP_OUT"
++      # on failure, Maven output already printed by tee
++      FAIL_DIFF=$(git diff)
++      log_debug "Diff content: $FAIL_DIFF"
++
++      if [ -n "$FAIL_DIFF" ]; then
++        # merge diff + maven output for summarization
++        COMBINED_CONTENT="$FAIL_DIFF"$'\n\nMAVEN OUTPUT:\n'"$TEST_OUTPUT"
++        RESET_SUMMARY=$(summarize_code "$COMBINED_CONTENT") || RESET_SUMMARY=""
++        RESET_SUMMARY=${RESET_SUMMARY:-"No summary from API"}
++        COMMIT_MSG="[TCR RESET] $RESET_SUMMARY"
++      else
++        COMMIT_MSG="[TCR RESET] No code changes detected."
++      fi
++
++      log_debug "Commit message: $COMMIT_MSG"
++      git reset --hard HEAD
++      git commit --allow-empty -m "$COMMIT_MSG"
++    fi
++  elif [[ $key == "f" || $key == "F" ]]; then
++    # just run tests, no git actions
++    echo "Running tests only (no commit/revert)..."
++    mvn clean test || true
++  else
++    echo "Unrecognized key '$key' – please press Enter or f."
++  fi
++done
++
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000..f728570
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,99 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.example</groupId>
+    <artifactId>social-network-coding-kata-manual</artifactId>
+    <version>1.0-SNAPSHOT</version>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <kotlin.code.style>official</kotlin.code.style>
+        <kotlin.compiler.jvmTarget>21</kotlin.compiler.jvmTarget>
+        <maven.compiler.source>21</maven.compiler.source>
+        <maven.compiler.target>21</maven.compiler.target>
+    </properties>
+
+    <repositories>
+        <repository>
+            <id>mavenCentral</id>
+            <url>https://repo1.maven.org/maven2/</url>
+        </repository>
+    </repositories>
+
+    <build>
+        <sourceDirectory>src/main/kotlin</sourceDirectory>
+        <testSourceDirectory>src/test/kotlin</testSourceDirectory>
+        <plugins>
+            <plugin>
+                <groupId>org.jetbrains.kotlin</groupId>
+                <artifactId>kotlin-maven-plugin</artifactId>
+                <version>1.9.23</version>
+                <executions>
+                    <execution>
+                        <id>compile</id>
+                        <phase>compile</phase>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>test-compile</id>
+                        <phase>test-compile</phase>
+                        <goals>
+                            <goal>test-compile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.11.0</version>
+                <configuration>
+                    <source>21</source>
+                    <target>21</target>
+                </configuration>
+            </plugin>
+            <plugin>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <version>3.2.5</version>
+            </plugin>
+            <plugin>
+                <artifactId>maven-failsafe-plugin</artifactId>
+                <version>3.2.5</version>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>exec-maven-plugin</artifactId>
+                <version>3.2.0</version>
+                <configuration>
+                    <mainClass>MainKt</mainClass>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jetbrains.kotlin</groupId>
+            <artifactId>kotlin-test-junit5</artifactId>
+            <version>1.9.23</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <version>5.11.0</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.jetbrains.kotlin</groupId>
+            <artifactId>kotlin-stdlib</artifactId>
+            <version>1.9.23</version>
+        </dependency>
+    </dependencies>
+
+</project>
+
diff --git a/renovate.json b/renovate.json
new file mode 100644
index 0000000..4a1ef1e
--- /dev/null
+++ b/renovate.json
@@ -0,0 +1,24 @@
+{
+  "extends": [
+    "config:base"
+  ],
+  "automerge": true,
+  "automergeType": "branch",
+  "labels": ["dependencies"],
+  "prConcurrentLimit": 5,
+  "prHourlyLimit": 2,
+  "dependencyDashboard": true,
+  "packageRules": [
+    {
+      "matchUpdateTypes": ["minor", "patch"],
+      "automerge": true
+    },
+    {
+      "matchUpdateTypes": ["major"],
+      "automerge": false
+    }
+  ],
+  "requireStatusChecks": true,
+  "rebaseWhen": "auto"
+}
+
diff --git a/results.ndjson b/results.ndjson
new file mode 100644
index 0000000..90f4d1e
--- /dev/null
+++ b/results.ndjson
@@ -0,0 +1,36 @@
+{
+  "ai_support_level": "completion",
+  "day": 1,
+  "main_use_cases_coverage": 3,
+  "additional_edge_cases": 1,
+  "time_to_completion_in_seconds": 1283,
+  "test_to_code_ratio": 0.65,
+  "average_assertions_per_test": 1.0,
+  "cyclomatic_complexity": 2,
+  "code_duplication_percentage": 0.0,
+  "code_smells": ["Dead Code"],
+  "test_focus_rating": 4,
+  "implementation_clean_code_rating": 4,
+  "test_clean_code_rating": 4,
+  "description": "The coding session, employing the Test-Commit-Revert (TCR) methodology with 'completion' level AI support on day 1, spanned approximately 21 minutes and 23 seconds according to the commit timestamps. The developer made steady progress, successfully committing 9 times without any reverts, resulting in a revert rate of 0.0. The commit log indicates a clear progression, averaging about 0.42 commits per minute: starting with basic message publishing and retrieval, moving to per-user timelines, allowing other users to view timelines, adding the subscription feature, and then refactoring the code by introducing `Timeline` and `TimelineRepository` classes and moving subscriber notification logic into the `Timeline` class. Finally, the test for multiple subscriptions was extended. The final code implements three main use cases of the social network kata: Posting, Reading, and Following. The tests cover the basic paths for these features and include one additional scenario (reading another user's timeline). The code structure is improved through refactoring into multiple classes, demonstrating good separation of concerns, although an unused field (\"Dead Code\") exists in the TimelineService. Both the implementation and test code adhere well to clean code principles, and the tests are behavior-focused with descriptive names. The average number of assertions per test is 1.0, indicating focused tests. The cyclomatic complexity is low, reflecting simple logic, and no significant code duplication was identified. The test-to-code ratio is approximately 0.65 (based on non-blank lines). Overall, this session shows effective progress and good coding practices within the constraints of TCR.",
+  "commits_per_minute": 0.42,
+  "tcr_revert_rate": 0.0
+}
+{
+  "ai_support_level": "completion",
+  "day": 2,
+  "main_use_cases_coverage": 5,
+  "additional_edge_cases": 3,
+  "time_to_completion_in_seconds": 1542,
+  "test_to_code_ratio": 0.986,
+  "average_assertions_per_test": 1.0,
+  "cyclomatic_complexity": 2,
+  "code_duplication_percentage": 0.0,
+  "code_smells": 1,
+  "test_focus_rating": 4,
+  "implementation_clean_code_rating": 4,
+  "test_clean_code_rating": 5,
+  "description": "The coding session, utilizing the Test-Commit-Revert (TCR) methodology with AI completion support, lasted exactly 25 minutes and 42 seconds (1542 seconds) based on the timestamps of the 14 successful commits. The commit log details a progressive development process beginning with the fundamental ability to post and retrieve messages, evolving quickly to support personal timelines, viewing other users' timelines, and implementing subscription functionality. Significant refactoring steps are evident, extracting timeline handling into a dedicated `Timeline` class, introducing a `TimelineRepository` for data access, and moving subscriber notification logic into the `Timeline` class itself, reflecting a clear focus on improving design and separation of concerns. The latter commits focused on implementing and testing encoding for user mentions (`@`) and web links (`http`/`https`). Based on the final code and tests, five of the six main social network requirements (Posting, Reading, Following via Subscription, Mentions, and Links) appear to be implemented. The tests cover basic scenarios for these features and include specific edge cases such as handling multiple subscriptions, messages containing both self and other user mentions, and messages with multiple URLs. Code quality is generally good, with well-structured classes (`TimelineService`, `TimelineRepository`, `Timeline`), small focused methods, and clear separation of concerns. One minor code smell, an unused `subscribers` field in `TimelineService`, was identified. Code duplication is minimal. Tests are well-written with highly descriptive names and follow a clear Arrange-Act-Assert pattern, focusing on observable behavior rather than implementation details, resulting in a high test clean code rating. The test-to-code ratio is nearly 1:1 (using total lines). The average cyclomatic complexity is low, indicative of simple function logic. The TCR methodology was followed successfully, with a 0% revert rate (based on the provided log of successful commits), resulting in steady, well-tested progress.",
+  "commits_per_minute": 0.54,
+  "tcr_revert_rate": 0.0
+}
diff --git a/src/main/kotlin/org/codingkata/socialnetwork/TimelineService.kt b/src/main/kotlin/org/codingkata/socialnetwork/TimelineService.kt
new file mode 100644
index 0000000..917b226
--- /dev/null
+++ b/src/main/kotlin/org/codingkata/socialnetwork/TimelineService.kt
@@ -0,0 +1,4 @@
+package org.codingkata.socialnetwork
+
+class TimelineService {
+}
\ No newline at end of file
diff --git a/src/test/kotlin/org/codingkata/socialnetwork/TimelineServiceTest.kt b/src/test/kotlin/org/codingkata/socialnetwork/TimelineServiceTest.kt
new file mode 100644
index 0000000..94abcaa
--- /dev/null
+++ b/src/test/kotlin/org/codingkata/socialnetwork/TimelineServiceTest.kt
@@ -0,0 +1,10 @@
+package org.codingkata.socialnetwork.org.codingkata.socialnetwork
+
+import org.junit.jupiter.api.Test
+
+class TimelineServiceTest {
+
+    @Test
+    fun example() {
+    }
+}
\ No newline at end of file
diff --git a/tcr.sh b/tcr.sh
new file mode 100755
index 0000000..bdc6d35
--- /dev/null
+++ b/tcr.sh
@@ -0,0 +1,143 @@
+#!/usr/bin/env bash
+# TCR (Test && Commit || Revert) automation script
+# Usage: tcr.sh [-d] [-c]  # -d = debug mode, -c = run single cycle and exit
+
+# parse flags
+DEBUG=0
+RUN_CYCLE=0
+while getopts "dc" opt; do
+  case $opt in
+    d) DEBUG=1 ;;
+    c) RUN_CYCLE=1 ;;
+  esac
+done
+shift $((OPTIND -1))
+
+log_debug() {
+  if [ "$DEBUG" -eq 1 ]; then
+    echo "$@" >&2
+  fi
+}
+
+# Default commit message
+COMMIT_MSG="WIP"
+
+# strict mode + better error detection
+set -euo pipefail
+
+# ensure API key is provided
+: "${GEMINI_API_KEY:?Environment variable GEMINI_API_KEY must be set}"
+
+# Function to summarize added code using Gemini API
+summarize_code() {
+  local diff_content="$1"
+  local response summary
+  # use the documented Gemini flash model
+  local api_url="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-04-17:generateContent?key=${GEMINI_API_KEY}"
+
+  response=$(curl -s \
+    -X POST \
+    -H "Content-Type: application/json" \
+    "$api_url" \
+    -d '{
+      "contents": [
+        {
+          "parts": [
+            {
+              "text": "I am doing TCR (test commit revert) and you are my commit summarizer. Your response should only be the commit message and the commit description, no other content or masking. Summarize the following code changes for a commit message:\n'"$(echo "$diff_content" | sed 's/"/\\"/g')"'"
+            }
+          ]
+        }
+      ]
+    }') || {
+      echo "Error: API request failed" >&2
+      return 1
+    }
+  log_debug "API response: $response"
+
+  # parse with jq if installed, else fallback to grep/sed
+  if command -v jq &>/dev/null; then
+    summary=$(printf '%s' "$response" \
+      | jq -r '.candidates[0].content.parts[0].text // empty')
+  else
+    summary=$(printf '%s' "$response" \
+      | grep -o '"text":[[:space:]]*"[^"]*"' \
+      | head -1 \
+      | sed 's/.*"text":[[:space:]]*"//;s/"$//')
+  fi
+
+  printf '%s' "$summary"
+}
+
+# Function to run a single TCR cycle
+run_tcr_cycle() {
+  echo "Running tests..."
+  # capture maven output with colors (force ANSI) while printing live
+  TMP_OUT=$(mktemp)
+  TEST_OUTPUT=""  # Initialize to avoid unbound variable
+  if mvn -Dstyle.color=always clean test 2>&1 | tee "$TMP_OUT"; then
+    TEST_OUTPUT=$(cat "$TMP_OUT"); rm "$TMP_OUT"
+    echo "Tests passed. Preparing commit..."
+    git add -A
+    ADDED_CODE=$(git diff --cached)
+    log_debug "Diff content: $ADDED_CODE"
+
+    if [ -n "$ADDED_CODE" ]; then
+      SUMMARY=$(summarize_code "$ADDED_CODE") || SUMMARY=""
+      SUMMARY=${SUMMARY:-"No summary from API"}
+      COMMIT_MSG="[TCR] $SUMMARY"
+      log_debug "Commit message: $COMMIT_MSG"
+      git commit -m "$COMMIT_MSG"
+    else
+      echo "No code changes detected. Keeping going..."
+    fi
+
+  else
+    TEST_OUTPUT=$(cat "$TMP_OUT" 2>/dev/null || true); rm -f "$TMP_OUT"
+    # on failure, Maven output already printed by tee
+    FAIL_DIFF=$(git diff)
+    log_debug "Diff content: $FAIL_DIFF"
+
+    if [ -n "$FAIL_DIFF" ]; then
+      # merge diff + maven output for summarization
+      COMBINED_CONTENT="$FAIL_DIFF"$'\n\nMAVEN OUTPUT:\n'"$TEST_OUTPUT"
+      RESET_SUMMARY=$(summarize_code "$COMBINED_CONTENT") || RESET_SUMMARY=""
+      RESET_SUMMARY=${RESET_SUMMARY:-"No summary from API"}
+      COMMIT_MSG="[TCR RESET] $RESET_SUMMARY"
+    else
+      COMMIT_MSG="[TCR RESET] No code changes detected."
+    fi
+
+    log_debug "Commit message: $COMMIT_MSG"
+    git reset --hard HEAD
+    git commit --allow-empty -m "$COMMIT_MSG"
+  fi
+}
+
+# Check if we should run a single cycle and exit
+if [ "$RUN_CYCLE" -eq 1 ]; then
+  echo "Running a single TCR cycle and exiting..."
+  run_tcr_cycle
+  exit 0
+fi
+
+# Main loop: wait for Enter key, then run tests and handle git accordingly
+echo "Starting a TCR coding kata session... Have fun 🚀!"
+echo "--------------------------------------------------"
+
+while true; do
+  # read a single key (silent, no newline)
+  read -rsn1 -p $'\n Enter - run the TCR cycle \n f - run tests only \n Ctrl+C to exit\n' key
+  echo
+  if [[ $key == "" ]]; then
+    # full TCR cycle
+    run_tcr_cycle
+  elif [[ $key == "f" || $key == "F" ]]; then
+    # just run tests, no git actions
+    echo "Running tests only (no commit/revert)..."
+    mvn clean test || true
+  else
+    echo "Unrecognized key '$key' – please press Enter or f."
+  fi
+done
+
